Learn C++ – Skill up with our free tutorialsLearnCpp.com is a free website devoted to teaching you how to program in modern C++. The lessons on this site will walk you through all the steps needed to write, compile, and debug your C++ programs. No prior programming experience is necessary, but programmers of all levels will benefit from our best practices, tips, and insights.Becoming an expert won’t happen overnight, but with a bit of patience, you’ll get there. And LearnCpp.com will show you the way.Chapter 0Introduction / Getting Started0.1Introduction to these tutorials0.2Introduction to programming languages0.3Introduction to C/C++0.4Introduction to C++ development0.5Introduction to the compiler, linker, and libraries0.6Installing an Integrated Development Environment (IDE)0.7Compiling your first program0.8A few common C++ problems0.9Configuring your compiler: Build configurations0.10Configuring your compiler: Compiler extensions0.11Configuring your compiler: Warning and error levels0.12Configuring your compiler: Choosing a language standard0.13What language standard is my compiler using?Chapter 1C++ Basics1.1Statements and the structure of a program1.2Comments1.3Introduction to objects and variables1.4Variable assignment and initialization1.5Introduction to iostream: cout, cin, and endl1.6Uninitialized variables and undefined behavior1.7Keywords and naming identifiers1.8Whitespace and basic formatting1.9Introduction to literals and operators1.10Introduction to expressions1.11Developing your first program1.xChapter 1 summary and quizChapter 2C++ Basics: Functions and Files2.1Introduction to functions2.2Function return values (value-returning functions)2.3Void functions (non-value returning functions)2.4Introduction to function parameters and arguments2.5Introduction to local scope2.6Why functions are useful, and how to use them effectively2.7Forward declarations and definitions2.8Programs with multiple code files2.9Naming collisions and an introduction to namespaces2.10Introduction to the preprocessor2.11Header files2.12Header guards2.13How to design your first programs2.xChapter 2 summary and quizChapter 3Debugging C++ Programs3.1Syntax and semantic errors3.2The debugging process3.3A strategy for debugging3.4Basic debugging tactics3.5More debugging tactics3.6Using an integrated debugger: Stepping3.7Using an integrated debugger: Running and breakpoints3.8Using an integrated debugger: Watching variables3.9Using an integrated debugger: The call stack3.10Finding issues before they become problems3.xChapter 3 summary and quizChapter 4Fundamental Data Types4.1Introduction to fundamental data types4.2Void4.3Object sizes and the sizeof operator4.4Signed integers4.5Unsigned integers, and why to avoid them4.6Fixed-width integers and size_t4.7Introduction to scientific notation4.8Floating point numbers4.9Boolean values4.10Introduction to if statements4.11Chars4.12Introduction to type conversion and static_cast4.xChapter 4 summary and quizChapter 5Constants and Strings5.1Constant variables (named constants)5.2Literals5.3Numeral systems (decimal, binary, hexadecimal, and octal)5.4The as-if rule and compile-time optimizationSplit5.5Constant expressionsUpdated5.6Constexpr variables5.7Introduction to std::string5.8Introduction to std::string_view5.9std::string_view (part 2)5.xChapter 5 summary and quizChapter 6Operators6.1Operator precedence and associativity6.2Arithmetic operators6.3Remainder and Exponentiation6.4Increment/decrement operators, and side effects6.5The comma operator6.6The conditional operatorMoved6.7Relational operators and floating point comparisons6.8Logical operators6.xChapter 6 summary and quizChapter OBit Manipulation (optional chapter)O.1Bit flags and bit manipulation via std::bitsetO.2Bitwise operatorsO.3Bit manipulation with bitwise operators and bit masksO.4Converting integers between binary and decimal representationChapter 7Scope, Duration, and Linkage7.1Compound statements (blocks)7.2User-defined namespaces and the scope resolution operator7.3Local variables7.4Introduction to global variables7.5Variable shadowing (name hiding)7.6Internal linkage7.7External linkage and variable forward declarations7.8Why (non-const) global variables are evil7.9Inline functions and variablesMoved7.10Sharing global constants across multiple files (using inline variables)7.11Static local variables7.12Scope, duration, and linkage summary7.13Using declarations and using directives7.14Unnamed and inline namespaces7.xChapter 7 summary and quizChapter 8Control Flow8.1Control flow introduction8.2If statements and blocks8.3Common if statement problems8.4Constexpr if statements8.5Switch statement basics8.6Switch fallthrough and scoping8.7Goto statements8.8Introduction to loops and while statements8.9Do while statements8.10For statements8.11Break and continue8.12Halts (exiting your program early)8.13Introduction to random number generation8.14Generating random numbers using Mersenne Twister8.15Global random numbers (Random.h)8.xChapter 8 summary and quizChapter 9Error Detection and Handling9.1Introduction to testing your code9.2Code coverage9.3Common semantic errors in C++9.4Detecting and handling errors9.5std::cin and handling invalid input9.6Assert and static_assert9.xChapter 9 summary and quizChapter 10Type Conversion, Type Aliases, and Type Deduction10.1Implicit type conversion10.2Floating-point and integral promotion10.3Numeric conversions10.4Narrowing conversions, list initialization, and constexpr initializers10.5Arithmetic conversions10.6Explicit type conversion (casting) and static_cast10.7Typedefs and type aliases10.8Type deduction for objects using the auto keyword10.9Type deduction for functions10.xChapter 10 summary and quizChapter 11Function Overloading and Function Templates11.1Introduction to function overloading11.2Function overload differentiation11.3Function overload resolution and ambiguous matches11.4Deleting functions11.5Default arguments11.6Function templates11.7Function template instantiation11.8Function templates with multiple template types11.9Non-type template parameters11.10Using function templates in multiple files11.xChapter 11 summary and quizChapter FConstexpr functionsF.1Constexpr functionsMovedF.2Constexpr functions (part 2)SplitF.3Constexpr functions (part 3) and constevalSplitF.4Constexpr functions (part 4)SplitF.XChapter F summary and quizSplitChapter 12Compound Types: References and Pointers12.1Introduction to compound data types12.2Value categories (lvalues and rvalues)12.3Lvalue references12.4Lvalue references to const12.5Pass by lvalue reference12.6Pass by const lvalue reference12.7Introduction to pointers12.8Null pointers12.9Pointers and const12.10Pass by address12.11Pass by address (part 2)12.12Return by reference and return by address12.13In and out parameters12.14Type deduction with pointers, references, and const12.15std::optional12.xChapter 12 summary and quizChapter 13Compound Types: Enums and Structs13.1Introduction to program-defined (user-defined) types13.2Unscoped enumerations13.3Unscoped enumerator integral conversions13.4Converting an enumeration to and from a string13.5Introduction to overloading the I/O operators13.6Scoped enumerations (enum classes)13.7Introduction to structs, members, and member selection13.8Struct aggregate initialization13.9Default member initialization13.10Passing and returning structs13.11Struct miscellany13.12Member selection with pointers and references13.13Class templates13.14Class template argument deduction (CTAD) and deduction guides13.15Alias templates13.xChapter 13 summary and quiz13.yUsing a language referenceChapter 14Introduction to Classes14.1Introduction to object-oriented programming14.2Introduction to classes14.3Member functions14.4Const class objects and const member functions14.5Public and private members and access specifiers14.6Access functions14.7Member functions returning references to data members14.8The benefits of data hiding (encapsulation)14.9Introduction to constructors14.10Constructor member initializer lists14.11Default constructors and default arguments14.12Delegating constructors14.13Temporary class objects14.14Introduction to the copy constructor14.15Class initialization and copy elision14.16Converting constructors and the explicit keyword14.17Constexpr aggregates and classes14.xChapter 14 summary and quizChapter 15More on Classes15.1The hidden “this” pointer and member function chaining15.2Classes and header files15.3Nested types (member types)15.4Introduction to destructors15.5Class templates with member functions15.6Static member variables15.7Static member functions15.8Friend non-member functions15.9Friend classes and friend member functions15.10Ref qualifiers15.xChapter 15 summary and quizChapter 16Dynamic arrays: std::vector16.1Introduction to containers and arrays16.2Introduction to std::vector and list constructors16.3std::vector and the unsigned length and subscript problem16.4Passing std::vector16.5Returning std::vector, and an introduction to move semantics16.6Arrays and loops16.7Arrays, loops, and sign challenge solutions16.8Range-based for loops (for-each)16.9Array indexing and length using enumerators16.10std::vector resizing and capacity16.11std::vector and stack behavior16.12std::vector<bool>16.xChapter 16 summary and quizChapter 17Fixed-size arrays: std::array and C-style arrays17.1Introduction to std::array17.2std::array length and indexing17.3Passing and returning std::array17.4std::array of class types, and brace elision17.5Arrays of references via std::reference_wrapper17.6std::array and enumerations17.7Introduction to C-style arrays17.8C-style array decay17.9Pointer arithmetic and subscripting17.10C-style strings17.11C-style string symbolic constants17.12Multidimensional C-style Arrays17.13Multidimensional std::array17.xChapter 17 summary and quizChapter 18Iterators and Algorithms (under construction)18.1Sorting an array using selection sort18.2Introduction to iterators18.3Introduction to standard library algorithms18.4Timing your codeChapter 19Dynamic Allocation (under construction)19.1Dynamic memory allocation with new and delete19.2Dynamically allocating arrays19.3Destructors19.4Pointers to pointers and dynamic multidimensional arrays19.5Void pointersChapter 20Functions20.1Function Pointers20.2The stack and the heap20.3Recursion20.4Command line arguments20.5Ellipsis (and why to avoid them)20.6Introduction to lambdas (anonymous functions)20.7Lambda captures20.xChapter 20 summary and quizChapter 21Operator Overloading21.1Introduction to operator overloading21.2Overloading the arithmetic operators using friend functions21.3Overloading operators using normal functions21.4Overloading the I/O operators21.5Overloading operators using member functions21.6Overloading unary operators +, -, and !21.7Overloading the comparison operators21.8Overloading the increment and decrement operators21.9Overloading the subscript operator21.10Overloading the parenthesis operator21.11Overloading typecasts21.12Overloading the assignment operator21.13Shallow vs. deep copying21.14Overloading operators and function templates21.xChapter 21 summary and quiz21.yChapter 21 projectChapter 22Move Semantics and Smart Pointers22.1Introduction to smart pointers and move semantics22.2R-value references22.3Move constructors and move assignment22.4std::move22.5std::unique_ptr22.6std::shared_ptr22.7Circular dependency issues with std::shared_ptr, and std::weak_ptr22.xChapter 22 summary and quizChapter 23Object Relationships23.1Object relationships23.2Composition23.3Aggregation23.4Association23.5Dependencies23.6Container classes23.7std::initializer_list23.xChapter 23 summary and quizChapter 24Inheritance24.1Introduction to inheritance24.2Basic inheritance in C++24.3Order of construction of derived classes24.4Constructors and initialization of derived classes24.5Inheritance and access specifiers24.6Adding new functionality to a derived class24.7Calling inherited functions and overriding behavior24.8Hiding inherited functionality24.9Multiple inheritance24.xChapter 24 summary and quizChapter 25Virtual Functions25.1Pointers and references to the base class of derived objects25.2Virtual functions and polymorphism25.3The override and final specifiers, and covariant return types25.4Virtual destructors, virtual assignment, and overriding virtualization25.5Early binding and late binding25.6The virtual table25.7Pure virtual functions, abstract base classes, and interface classes25.8Virtual base classes25.9Object slicing25.10Dynamic casting25.11Printing inherited classes using operator<<25.xChapter 25 summary and quizChapter 26Templates and Classes26.1Template classes26.2Template non-type parameters26.3Function template specialization26.4Class template specialization26.5Partial template specialization26.6Partial template specialization for pointers26.xChapter 26 summary and quizChapter 27Exceptions27.1The need for exceptions27.2Basic exception handling27.3Exceptions, functions, and stack unwinding27.4Uncaught exceptions and catch-all handlers27.5Exceptions, classes, and inheritance27.6Rethrowing exceptions27.7Function try blocks27.8Exception dangers and downsides27.9Exception specifications and noexcept27.10std::move_if_noexcept27.xChapter 27 summary and quizChapter 28Input and Output (I/O)28.1Input and output (I/O) streams28.2Input with istream28.3Output with ostream and ios28.4Stream classes for strings28.5Stream states and input validation28.6Basic file I/O28.7Random file I/OAppendix AMiscellaneous SubjectsA.1Static and dynamic librariesA.2Using libraries with Visual StudioA.3Using libraries with Code::BlocksA.4C++ FAQAppendix BC++ UpdatesB.1Introduction to C++11B.2Introduction to C++14B.3Introduction to C++17B.4Introduction to C++20B.5Introduction to C++23Appendix CThe EndC.1The end?Appendix DDeprecated Articles (will be removed soon)21.1The Standard Library21.2STL containers overview21.3STL iterators overview21.4STL algorithms overview22.1std::string and std::wstring22.2std::string construction and destruction22.3std::string length and capacity22.4std::string character access and conversion to C-style arrays22.5std::string assignment and swapping22.6std::string appending22.7std::string inserting